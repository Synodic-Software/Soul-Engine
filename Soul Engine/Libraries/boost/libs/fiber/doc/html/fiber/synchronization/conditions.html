<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Condition Variables</title>
<link rel="stylesheet" href="../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Fiber">
<link rel="up" href="../synchronization.html" title="Synchronization">
<link rel="prev" href="mutex_types.html" title="Mutex Types">
<link rel="next" href="barriers.html" title="Barriers">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="mutex_types.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../synchronization.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="barriers.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="fiber.synchronization.conditions"></a><a class="link" href="conditions.html" title="Condition Variables">Condition Variables</a>
</h3></div></div></div>
<h5>
<a name="fiber.synchronization.conditions.h0"></a>
        <span><a name="fiber.synchronization.conditions.synopsis"></a></span><a class="link" href="conditions.html#fiber.synchronization.conditions.synopsis">Synopsis</a>
      </h5>
<pre class="programlisting"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">cv_status</span><span class="special">;</span> <span class="special">{</span>
    <span class="identifier">no_timeout</span><span class="special">,</span>
    <span class="identifier">timeout</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">condition_variable</span><span class="special">;</span>
<span class="keyword">class</span> <span class="identifier">condition_variable_any</span><span class="special">;</span>
</pre>
<p>
        The class <code class="computeroutput"><span class="identifier">condition_variable</span></code>
        provides a mechanism for a fiber to wait for notification from another fiber.
        When the fiber awakens from the wait, then it checks to see if the appropriate
        condition is now true, and continues if so. If the condition is not true,
        then the fiber calls <code class="computeroutput"><span class="identifier">wait</span></code>
        again to resume waiting. In the simplest case, this condition is just a boolean
        variable:
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">condition_variable</span> <span class="identifier">cond</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">data_ready</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>

<span class="keyword">void</span> <span class="identifier">process_data</span><span class="special">();</span>

<span class="keyword">void</span> <span class="identifier">wait_for_data_to_process</span><span class="special">()</span> <span class="special">{</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">mutex</span> <span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">(</span> <span class="identifier">mtx</span><span class="special">);</span>
        <span class="keyword">while</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">data_ready</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">cond</span><span class="special">.</span><span class="identifier">wait</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">);</span>
        <span class="special">}</span>
    <span class="special">}</span>   <span class="comment">// release lk</span>
    <span class="identifier">process_data</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        Notice that the <code class="computeroutput"><span class="identifier">lk</span></code> is passed
        to <code class="computeroutput"><span class="identifier">wait</span></code>: <code class="computeroutput"><span class="identifier">wait</span></code>
        will atomically add the fiber to the set of fibers waiting on the condition
        variable, and unlock the mutex. When the fiber is awakened, the mutex will
        be locked again before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
        returns. This allows other fibers to acquire the mutex in order to update
        the shared data, and ensures that the data associated with the condition
        is correctly synchronized.
      </p>
<p>
        In the meantime, another fiber sets <code class="computeroutput"><span class="identifier">data_ready</span></code>
        to <code class="computeroutput"><span class="keyword">true</span></code>, and then calls either
        <code class="computeroutput"><span class="identifier">notify_one</span></code> or <code class="computeroutput"><span class="identifier">notify_all</span></code> on the condition variable <code class="computeroutput"><span class="identifier">cond</span></code> to wake one waiting fiber or all the
        waiting fibers respectively.
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">retrieve_data</span><span class="special">();</span>
<span class="keyword">void</span> <span class="identifier">prepare_data</span><span class="special">();</span>

<span class="keyword">void</span> <span class="identifier">prepare_data_for_processing</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">retrieve_data</span><span class="special">();</span>
    <span class="identifier">prepare_data</span><span class="special">();</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">mutex</span> <span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">(</span> <span class="identifier">mtx</span><span class="special">);</span>
        <span class="identifier">data_ready</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="identifier">cond</span><span class="special">.</span><span class="identifier">notify_one</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        Note that the same mutex is locked before the shared data is updated, but
        that the mutex does not have to be locked across the call to <code class="computeroutput"><span class="identifier">notify_one</span></code>.
      </p>
<p>
        Locking is important because the synchronization objects provided by <span class="bold"><strong>Boost.Fiber</strong></span> can be used to synchronize fibers running
        on different threads.
      </p>
<p>
        <span class="bold"><strong>Boost.Fiber</strong></span> provides both <code class="computeroutput"><span class="identifier">condition_variable</span></code> and <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>
        because <a href="http://www.boost.org/doc/libs/release/libs/thread/index.html" target="_top">Boost.Thread</a>
        provides both. (<span class="bold"><strong>Boost.Fiber</strong></span> also provides
        the name <code class="computeroutput"><span class="identifier">condition</span></code>, which
        has been deprecated in <a href="http://www.boost.org/doc/libs/release/libs/thread/index.html" target="_top">Boost.Thread</a>.)
        However, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">fiber</span><span class="special">::</span><span class="identifier">condition_variable</span></code> and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">fiber</span><span class="special">::</span><span class="identifier">condition_variable_any</span></code>
        are the same class; like <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span><span class="special">::</span><span class="identifier">condition_variable_any</span></code>,
        its wait() method will accept any form of lock. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">fiber</span><span class="special">::</span><span class="identifier">condition_variable_any</span></code>
        has no need to further optimize as described for <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span><span class="special">::</span><span class="identifier">condition_variable</span></code>.
      </p>
<p>
        </p>
<h5>
<a name="class_condition_variable_bridgehead"></a>
  <span><a name="class_condition_variable"></a></span>
  <a class="link" href="conditions.html#class_condition_variable">Class
        <code class="computeroutput">condition_variable</code></a>
</h5>
<p>
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">condition</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">enum</span> <span class="identifier">cv_status</span> <span class="special">{</span>
    <span class="identifier">no_timeout</span><span class="special">,</span>
    <span class="identifier">timeout</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">condition_variable</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">condition_variable</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">condition_variable</span><span class="special">();</span>

    <span class="identifier">condition_variable</span><span class="special">(</span> <span class="identifier">condition_variable</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">condition_variable</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">condition_variable</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">();</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span> <span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span> <span class="identifier">Pred</span> <span class="identifier">predicate</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
    <span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
                          <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
                     <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">,</span>
                     <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
    <span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
                        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
                   <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">,</span>
                   <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>
<span class="special">};</span>

<span class="keyword">typedef</span> <span class="identifier">condition_variable</span> <span class="identifier">condition_variable_any</span><span class="special">;</span>
</pre>
<h5>
<a name="fiber.synchronization.conditions.h1"></a>
        <span><a name="fiber.synchronization.conditions.constructor"></a></span><a class="link" href="conditions.html#fiber.synchronization.conditions.constructor">Constructor</a>
      </h5>
<pre class="programlisting"><span class="identifier">condition_variable</span><span class="special">()</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
              Creates the object.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              Nothing.
            </p></dd>
</dl>
</div>
<h5>
<a name="fiber.synchronization.conditions.h2"></a>
        <span><a name="fiber.synchronization.conditions.destructor"></a></span><a class="link" href="conditions.html#fiber.synchronization.conditions.destructor">Destructor</a>
      </h5>
<pre class="programlisting"><span class="special">~</span><span class="identifier">condition_variable</span><span class="special">()</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
              All fibers waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> have been notified by a call to
              <code class="computeroutput"><span class="identifier">notify_one</span></code> or <code class="computeroutput"><span class="identifier">notify_all</span></code> (though the respective
              calls to <code class="computeroutput"><span class="identifier">wait</span></code>, <code class="computeroutput"><span class="identifier">wait_for</span></code> or <code class="computeroutput"><span class="identifier">wait_until</span></code>
              need not have returned).
            </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
              Destroys the object.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              Nothing.
            </p></dd>
</dl>
</div>
<p>
        </p>
<h5>
<a name="condition_variable_notify_one_bridgehead"></a>
  <span><a name="condition_variable_notify_one"></a></span>
  <a class="link" href="conditions.html#condition_variable_notify_one">Member
        function <code class="computeroutput">notify_one</code>()</a>
</h5>
<p>
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
              If any fibers are currently <a class="link" href="../overview.html#blocking"><span class="emphasis"><em>blocked</em></span></a>
              waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
              in a call to <code class="computeroutput"><span class="identifier">wait</span></code>,
              <code class="computeroutput"><span class="identifier">wait_for</span></code> or <code class="computeroutput"><span class="identifier">wait_until</span></code>, unblocks one of those
              fibers.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              Nothing.
            </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
              It is arbitrary which waiting fiber is resumed.
            </p></dd>
</dl>
</div>
<p>
        </p>
<h5>
<a name="condition_variable_notify_all_bridgehead"></a>
  <span><a name="condition_variable_notify_all"></a></span>
  <a class="link" href="conditions.html#condition_variable_notify_all">Member
        function <code class="computeroutput">notify_all</code>()</a>
</h5>
<p>
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
              If any fibers are currently <a class="link" href="../overview.html#blocking"><span class="emphasis"><em>blocked</em></span></a>
              waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
              in a call to <code class="computeroutput"><span class="identifier">wait</span></code>,
              <code class="computeroutput"><span class="identifier">wait_for</span></code> or <code class="computeroutput"><span class="identifier">wait_until</span></code>, unblocks all of those
              fibers.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              Nothing.
            </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
              This is why a waiting fiber must <span class="emphasis"><em>also</em></span> check for
              the desired program state using a mechanism external to the <code class="computeroutput"><span class="identifier">condition_variable</span></code>, and retry the
              wait until that state is reached. A fiber waiting on a <code class="computeroutput"><span class="identifier">condition_variable</span></code> might well wake
              up a number of times before the desired state is reached.
            </p></dd>
</dl>
</div>
<p>
        </p>
<h5>
<a name="condition_variable_wait_bridgehead"></a>
  <span><a name="condition_variable_wait"></a></span>
  <a class="link" href="conditions.html#condition_variable_wait">Templated
        member function <code class="computeroutput">wait</code>()</a>
</h5>
<p>
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span> <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">lk</span></code> is locked by the
              current fiber, and either no other fiber is currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
              or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lk</span></code> objects supplied in the calls
              to <code class="computeroutput"><span class="identifier">wait</span></code> in all the
              fibers currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value as
              <code class="computeroutput"><span class="identifier">lk</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
              for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
            </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
              Atomically call <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current fiber. The
              fiber will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code> or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>, or spuriously. When the fiber is
              unblocked (for whatever reason), the lock is reacquired by invoking
              <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
              before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
              returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an exception.
              The member function accepting <code class="computeroutput"><span class="identifier">pred</span></code>
              is shorthand for:
</p>
<pre class="programlisting"><span class="keyword">while</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">pred</span><span class="special">()</span> <span class="special">)</span> <span class="special">{</span>
    <span class="identifier">wait</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            </p>
</dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">lk</span></code> is locked by the
              current fiber.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">fiber_exception</span></code> if
              an error occurs. <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
              if the wait was interrupted by a call to <a class="link" href="../fiber_mgmt/fiber.html#fiber_interrupt"> <code class="computeroutput">fiber::interrupt()</code></a> on
              the <a class="link" href="../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a> object associated with the current fiber of execution.
            </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
              The Precondition is a bit dense. It merely states that all the fibers
              calling <code class="computeroutput"><span class="identifier">wait</span></code> on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
              must wait on <code class="computeroutput"><span class="identifier">lk</span></code> objects
              governing the <span class="emphasis"><em>same</em></span> <code class="computeroutput"><span class="identifier">mutex</span></code>.
              Three distinct objects are involved in any <code class="computeroutput"><span class="identifier">condition_variable</span><span class="special">::</span><span class="identifier">wait</span><span class="special">()</span></code> call: the <code class="computeroutput"><span class="identifier">condition_variable</span></code>
              itself, the <code class="computeroutput"><span class="identifier">mutex</span></code> coordinating
              access between fibers and a lock object (e.g. <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span></code>).
              In some sense it would be nice if the <code class="computeroutput"><span class="identifier">condition_variable</span></code>'s
              constructor could accept the related <code class="computeroutput"><span class="identifier">mutex</span></code>
              object, enforcing agreement across all <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code> calls; but the existing APIs prevent
              that. Instead we must require the <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code> call to accept a reference to the
              local lock object. It is an error to reuse a given <code class="computeroutput"><span class="identifier">condition_variable</span></code>
              instance with lock objects that reference <span class="emphasis"><em>different</em></span>
              underlying <code class="computeroutput"><span class="identifier">mutex</span></code> objects.
              It would be like a road intersection with traffic lights independent
              of one another: sooner or later a collision will result.
            </p></dd>
</dl>
</div>
<p>
        </p>
<h5>
<a name="condition_variable_wait_until_bridgehead"></a>
  <span><a name="condition_variable_wait_until"></a></span>
  <a class="link" href="conditions.html#condition_variable_wait_until">Templated
        member function <code class="computeroutput">wait_until</code>()</a>
</h5>
<p>
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
<span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
                      <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
                 <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">,</span>
                 <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">lk</span></code> is locked by the
              current fiber, and either no other fiber is currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
              or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lk</span></code> objects supplied in the calls
              to <code class="computeroutput"><span class="identifier">wait</span></code>, <code class="computeroutput"><span class="identifier">wait_for</span></code> or <code class="computeroutput"><span class="identifier">wait_until</span></code>
              in all the fibers currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value as
              <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()</span></code>
              for this call to <code class="computeroutput"><span class="identifier">wait_until</span></code>.
            </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
              Atomically call <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current fiber. The
              fiber will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code> or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>, when the system time would be equal
              to or later than the specified <code class="computeroutput"><span class="identifier">timeout_time</span></code>,
              or spuriously. When the fiber is unblocked (for whatever reason), the
              lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait_until</span></code> returns. The lock is also
              reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an exception.
              The member function accepting <code class="computeroutput"><span class="identifier">pred</span></code>
              is shorthand for:
</p>
<pre class="programlisting"><span class="keyword">while</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">pred</span><span class="special">()</span> <span class="special">)</span> <span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span> <span class="special">==</span> <span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">,</span> <span class="identifier">timeout_time</span><span class="special">)</span> <span class="special">)</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
              That is, even if <code class="computeroutput"><span class="identifier">wait_until</span><span class="special">()</span></code> times out, it can still return <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="identifier">pred</span><span class="special">()</span></code> returns <code class="computeroutput"><span class="keyword">true</span></code>
              at that time.
            </p>
</dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">lk</span></code> is locked by the
              current fiber.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">fiber_exception</span></code> if
              an error occurs. <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
              if the wait was interrupted by a call to <a class="link" href="../fiber_mgmt/fiber.html#fiber_interrupt"> <code class="computeroutput">fiber::interrupt()</code></a> on
              the <a class="link" href="../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a> object associated with the current fiber of execution.
            </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
              The overload without <code class="computeroutput"><span class="identifier">pred</span></code>
              returns <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span></code> if awakened by <code class="computeroutput"><span class="identifier">notify_one</span><span class="special">()</span></code>
              or <code class="computeroutput"><span class="identifier">notify_all</span><span class="special">()</span></code>,
              or <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span></code> if awakened because the system
              time is past <code class="computeroutput"><span class="identifier">timeout_time</span></code>.
            </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
              The overload accepting <code class="computeroutput"><span class="identifier">pred</span></code>
              returns <code class="computeroutput"><span class="keyword">false</span></code> if the call
              is returning because the time specified by <code class="computeroutput"><span class="identifier">timeout_time</span></code>
              was reached and the predicate returns <code class="computeroutput"><span class="keyword">false</span></code>,
              <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
            </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
              See <span class="bold"><strong>Note</strong></span> for <a class="link" href="conditions.html#condition_variable_wait"> <code class="computeroutput">condition_variable::wait()</code></a>.
            </p></dd>
</dl>
</div>
<p>
        </p>
<h5>
<a name="condition_variable_wait_for_bridgehead"></a>
  <span><a name="condition_variable_wait_for"></a></span>
  <a class="link" href="conditions.html#condition_variable_wait_for">Templated
        member function <code class="computeroutput">wait_for</code>()</a>
</h5>
<p>
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
<span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
                    <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
               <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">,</span>
               <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">lk</span></code> is locked by the
              current fiber, and either no other fiber is currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
              or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lk</span></code> objects supplied in the calls
              to <code class="computeroutput"><span class="identifier">wait</span></code>, <code class="computeroutput"><span class="identifier">wait_for</span></code> or <code class="computeroutput"><span class="identifier">wait_until</span></code>
              in all the fibers currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value as
              <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()</span></code>
              for this call to <code class="computeroutput"><span class="identifier">wait_for</span></code>.
            </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
              Atomically call <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current fiber. The
              fiber will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code> or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>, when a time interval equal to or
              greater than the specified <code class="computeroutput"><span class="identifier">timeout_duration</span></code>
              has elapsed, or spuriously. When the fiber is unblocked (for whatever
              reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also reacquired
              by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
              if the function exits with an exception. The <code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code> member function accepting <code class="computeroutput"><span class="identifier">pred</span></code> is shorthand for:
</p>
<pre class="programlisting"><span class="keyword">while</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">pred</span><span class="special">()</span> <span class="special">)</span> <span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span> <span class="special">==</span> <span class="identifier">wait_for</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">,</span> <span class="identifier">timeout_duration</span><span class="special">)</span> <span class="special">)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
              (except of course that <code class="computeroutput"><span class="identifier">timeout_duration</span></code>
              is adjusted for each iteration). The point is that, even if <code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code>
              times out, it can still return <code class="computeroutput"><span class="keyword">true</span></code>
              if <code class="computeroutput"><span class="identifier">pred</span><span class="special">()</span></code>
              returns <code class="computeroutput"><span class="keyword">true</span></code> at that time.
            </p>
</dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">lk</span></code> is locked by the
              current fiber.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">fiber_exception</span></code> if
              an error occurs. <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
              if the wait was interrupted by a call to <a class="link" href="../fiber_mgmt/fiber.html#fiber_interrupt"> <code class="computeroutput">fiber::interrupt()</code></a> on
              the <a class="link" href="../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a> object associated with the current fiber of execution.
            </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
              The overload without <code class="computeroutput"><span class="identifier">pred</span></code>
              returns <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span></code> if awakened by <code class="computeroutput"><span class="identifier">notify_one</span><span class="special">()</span></code>
              or <code class="computeroutput"><span class="identifier">notify_all</span><span class="special">()</span></code>,
              or <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span></code> if awakened because at least
              <code class="computeroutput"><span class="identifier">timeout_duration</span></code> has
              elapsed.
            </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
              The overload accepting <code class="computeroutput"><span class="identifier">pred</span></code>
              returns <code class="computeroutput"><span class="keyword">false</span></code> if the call
              is returning because at least <code class="computeroutput"><span class="identifier">timeout_duration</span></code>
              has elapsed and the predicate returns <code class="computeroutput"><span class="keyword">false</span></code>,
              <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
            </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
              See <span class="bold"><strong>Note</strong></span> for <a class="link" href="conditions.html#condition_variable_wait"> <code class="computeroutput">condition_variable::wait()</code></a>.
            </p></dd>
</dl>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013 Oliver Kowalke<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="mutex_types.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../synchronization.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="barriers.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
