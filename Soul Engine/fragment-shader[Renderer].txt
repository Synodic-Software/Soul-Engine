 #version 430

	layout( std430, binding=0 ) buffer texB 
	{
		vec4 tex[];
	};

	layout(origin_upper_left,pixel_center_integer) in vec4 gl_FragCoord;

	//in vec2 texCoord_FS_in;
    out vec4 fragment;

	uniform uvec2 screenMod;
	uniform uvec2 screen;

    void main(){

		vec2 pos= gl_FragCoord.xy*(screenMod/screen);


int px = floor(pos.x); // floor of x
int py = floor(pos.y); // floor of y

// load the four neighboring pixels
vec4 p1 = tex[py*screenMod.x+px];
vec4 p2 = tex[(py+1)*screenMod.x+px];
vec4 p3 = tex[py*screenMod.x+(px+1)];
vec4 p4 = tex[(py+1)*screenMod.x+(px+1)];

// Calculate the weights for each pixel
float fx = x - px;
float fy = y - py;
float fx1 = 1.0f - fx;
float fy1 = 1.0f - fy;

flaot w1 = fx1 * fy1;
float w2 = fx  * fy1;
float w3 = fx1 * fy ;
float w4 = fx  * fy ;

// Calculate the weighted sum of pixels (for each color channel)
int outr = p1.r * w1 + p2.r * w2 + p3.r * w3 + p4.r * w4;
int outg = p1.g * w1 + p2.g * w2 + p3.g * w3 + p4.g * w4;
int outb = p1.b * w1 + p2.b * w2 + p3.b * w3 + p4.b * w4;
int outa = p1.a * w1 + p2.a * w2 + p3.a * w3 + p4.a * w4;





		//*(screenMod-1.0f)+0.5f;

	//	vec4 interp2=mix(tex[uint(ceil(pos.y)*screen.x+floor(pos.x))],tex[uint(ceil(pos.y)*screen.x+ceil(pos.x))],pos.x-uint(pos.x));
	//	vec4 interp1=mix(tex[uint(floor(pos.y)*screen.x+floor(pos.x))],tex[uint(floor(pos.y)*screen.x+ceil(pos.x))],pos.x-uint(pos.x));

	//	vec4 Color=mix(interp1,interp2,pos.y-floor(pos.y));

	//	fragment = vec4(Color.x,Color.y,Color.z,1.0f);
	}